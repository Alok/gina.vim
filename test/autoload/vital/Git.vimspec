let s:git_version = matchstr(system('git --version'), '\%(\d\+\.\)\+\d')
let s:git_support_worktree = s:git_version !~# '^\%([01]\..*\|2\.4\..*\)$'


Describe Git
  Before all
    let Path = vital#gina#import('System.Filepath')
    let profile = s:new_profile()
  End

  Before
    let Git = vital#gina#import('Git')
  End

  Describe .new({path})
    Context A normal git working tree
      It returns a git instance of {path}
        let git = Git.new(profile.valid1)
        " Attributes
        Assert KeyExists(git, 'worktree')
        Assert KeyExists(git, 'repository')
        Assert KeyExists(git, 'commondir')
        Assert True(islocked('git.worktree'))
        Assert True(islocked('git.repository'))
        Assert True(islocked('git.commondir'))
        Assert Equals(git.worktree, profile.valid1)
        Assert Equals(git.repository, Path.join(profile.valid1, '.git'))
        Assert Equals(git.commondir, '')
      End

      It returns a git instance of a worktree which {path} belongs
        let path1 = Path.join(profile.valid1, 'A', 'foo', 'bar.txt')
        let path2 = Path.join(profile.valid1, 'B', 'foo', 'bar.txt')
        let path3 = Path.join(profile.valid1, 'C', 'foo')

        let git1 = Git.new(path1)
        let git2 = Git.new(path2)
        let git3 = Git.new(path3)
        Assert Equals(git1.worktree, profile.valid1)
        Assert Equals(git1.repository, Path.join(profile.valid1, '.git'))
        Assert Equals(git1.commondir, '')
        Assert Equals(git1, git2)
        Assert Equals(git1, git3)
      End
    End

    if s:git_support_worktree
      Context A git working tree by 'git worktree'
        It returns a git instance of {path}
          let git = Git.new(profile.valid2)
          " Attributes
          Assert KeyExists(git, 'worktree')
          Assert KeyExists(git, 'repository')
          Assert KeyExists(git, 'commondir')
          Assert True(islocked('git.worktree'))
          Assert True(islocked('git.repository'))
          Assert True(islocked('git.commondir'))
          Assert Equals(git.worktree, profile.valid2)
          Assert Equals(git.repository, Path.join(
                \ profile.valid1, '.git', 'worktrees', 'valid2'
                \))
          Assert Equals(git.commondir, Path.join(profile.valid1, '.git'))
        End

        It returns a git instance of a worktree which {path} belongs
          let path1 = Path.join(profile.valid2, 'A', 'foo', 'bar.txt')
          let path2 = Path.join(profile.valid2, 'B', 'foo', 'bar.txt')
          let path3 = Path.join(profile.valid2, 'C', 'foo')

          let git1 = Git.new(path1)
          let git2 = Git.new(path2)
          let git3 = Git.new(path3)
          Assert Equals(git1.worktree, profile.valid2)
          Assert Equals(git1.repository, Path.join(
                \ profile.valid1, '.git', 'worktrees', 'valid2'
                \))
          Assert Equals(git1.commondir, Path.join(profile.valid1, '.git'))
          Assert Equals(git1, git2)
          Assert Equals(git1, git3)
        End
      End
    endif

    Context A non git repository
      It returns an empty dictionary of {path}
        let git = Git.new(profile.invalid)
        Assert Equals(git, {})

        let git = Git.new(Path.join(profile.invalid, 'A', 'foo', 'bar.txt'))
        Assert Equals(git, {})

        let git = Git.new(Path.join(profile.invalid, 'B', 'foo', 'bar.txt'))
        Assert Equals(git, {})

        let git = Git.new(Path.join(profile.invalid, 'C', 'foo'))
        Assert Equals(git, {})
      End
    End
  End

  Describe .resolve({git}, {path})
    It returns an absolute path of {path} in a .git directory
      let git = Git.new(profile.valid1)
      let path = Git.resolve(git, 'HEAD')
      Assert Equals(path, Path.join(git.repository, 'HEAD'))
    End
  End
End


" To create a test profile ---------------------------------------------------
let s:Path = vital#gina#import('System.Filepath')

let s:git = {}

function! s:git.execute(...) abort
  let command = a:0 == 1 ? a:1 : call('printf', a:000)
  let args = [
        \ 'git',
        \ '-c color.ui=false',
        \ '-c core.editor=false',
        \ '--no-pager',
        \]
  if !empty(get(self, 'worktree'))
    let args += ['-C', fnameescape(self.worktree)]
  endif
  return system(join(args + [command]))
endfunction

function! s:new_profile() abort
  let root = resolve(tempname())
  let valid1 = s:Path.join(root, 'valid1')  " Normal
  let valid2 = s:Path.join(root, 'valid2')  " Worktree (git worktree)
  let valid3 = s:Path.join(root, 'valid3')  " For external remote
  let invalid = s:Path.join(root, 'invalid')

  " Build files and directories
  for path in [valid1, valid3, invalid]
    call mkdir(s:Path.join(path, 'A', 'foo'), 'p')
    call mkdir(s:Path.join(path, 'B', 'foo'), 'p')
    call mkdir(s:Path.join(path, 'C', 'foo'), 'p')
    call writefile(['A'], s:Path.join(path, 'A', 'foo', 'bar.txt'))
    call writefile(['B'], s:Path.join(path, 'B', 'foo', 'bar.txt'))
    call writefile(['C'], s:Path.join(path, 'C', 'foo', 'bar.txt'))
  endfor

  " Configure git repository
  let git = copy(s:git)
  let git.worktree = valid1
  call git.execute('init')
  call git.execute('add %s', fnameescape(s:Path.realpath('A/foo/bar.txt')))
  call git.execute('commit --quiet -m "First"')
  call git.execute('checkout --track -b develop')
  call git.execute('add %s', fnameescape(s:Path.realpath('B/foo/bar.txt')))
  call git.execute('commit --quiet -m "Second"')
  call git.execute('checkout master')
  call git.execute('add %s', fnameescape(s:Path.realpath('C/foo/bar.txt')))
  call git.execute('commit --quiet -m "Third"')

  if s:git_support_worktree
    call git.execute('worktree add %s develop', fnameescape(valid2))
  endif

  let git.worktree = valid3
  call git.execute('init')
  call git.execute('add %s', fnameescape(s:Path.realpath('A/foo/bar.txt')))
  call git.execute('commit --quiet -m "Fourth"')

  let git.worktree = valid1
  call git.execute('remote add ext %s', fnameescape(valid3))
  call git.execute('fetch ext')
  call git.execute('checkout --track -b ext/master remotes/ext/master')
  call git.execute('checkout master')

  return {
        \ 'root': root,
        \ 'valid1': valid1,
        \ 'valid2': valid2,
        \ 'valid3': valid3,
        \ 'invalid': invalid,
        \ 'git': copy(s:git),
        \}
endfunction
