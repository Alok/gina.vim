Describe gina#core
  Before all
    let Path = vital#gina#import('System.Filepath')
  End

  Before
    windo bwipeout!
  End

  Describe #get_or_fail()
    It throws an exception for a non git working-tree directory
      execute 'edit' fnameescape(g:git_profile.invalid)
      Throws /No git repository/ gina#core#get_or_fail()
    End

    It returns a git instance for a git working-tree directory
      execute 'edit' fnameescape(g:git_profile.valid1)
      let git = gina#core#get_or_fail()
      Assert Equals(git.refname, 'valid1')
      Assert Equals(git.worktree, g:git_profile.valid1)
      Assert Equals(git.repository, Path.join(g:git_profile.valid1, '.git'))
      Assert Equals(git.commondir, '')
    End
  End

  Describe #get()
    It returns an empty dictionary for a non git working-tree directory
      execute 'edit' fnameescape(g:git_profile.invalid)
      let git = gina#core#get()
      Assert Equals(git, {})
    End

    It returns a git instance for a git working-tree directory
      execute 'edit' fnameescape(g:git_profile.valid1)
      let git = gina#core#get()
      Assert Equals(git.refname, 'valid1')
      Assert Equals(git.worktree, g:git_profile.valid1)
      Assert Equals(git.repository, Path.join(g:git_profile.valid1, '.git'))
      Assert Equals(git.commondir, '')
    End

    It returns a git instance for a git worktree directory
      if !g:git_profile.git_support_worktree
        Skip This git does not support 'worktree' feature.
      endif
      execute 'edit' fnameescape(g:git_profile.valid2)
      let git = gina#core#get()
      Assert Equals(git.refname, 'valid2')
      Assert Equals(git.worktree, g:git_profile.valid2)
      Assert Equals(git.repository, Path.join(
            \ g:git_profile.valid1, '.git', 'worktrees', 'valid2'
            \))
      Assert Equals(git.commondir, Path.join(g:git_profile.valid1, '.git'))
    End

    Context A symbolic link
      It returns a git instance which the symlink file belongs
        " NOTE: The symlink1 points a file in invalid
        execute 'edit' fnameescape(g:git_profile.symlink1)
        let git = gina#core#get()
        Assert Equals(git.refname, 'valid1')
        Assert Equals(git.worktree, g:git_profile.valid1)
        Assert Equals(git.repository, Path.join(g:git_profile.valid1, '.git'))
        Assert Equals(git.commondir, '')

        " NOTE: The symlink2 points a file in valid3
        execute 'edit' fnameescape(g:git_profile.symlink2)
        let git = gina#core#get()
        Assert Equals(git.refname, 'valid1')
        Assert Equals(git.worktree, g:git_profile.valid1)
        Assert Equals(git.repository, Path.join(g:git_profile.valid1, '.git'))
        Assert Equals(git.commondir, '')
      End

      It returns a git instance which the original file belogns if the symlink file does not belong
        " NOTE: The symlink3 points a file in valid1
        execute 'edit' fnameescape(g:git_profile.symlink3)
        let git = gina#core#get()
        Assert Equals(git.refname, 'valid1')
        Assert Equals(git.worktree, g:git_profile.valid1)
        Assert Equals(git.repository, Path.join(g:git_profile.valid1, '.git'))
        Assert Equals(git.commondir, '')
      End
    End
  End
End
