let s:is_windows = has('win32') || has('win64')

Describe gina#util
  Before
    let Path = vital#gina#import('System.Filepath')
  End

  Describe #yank({value})
    It assigns {value} to v:register
      call gina#util#yank('foobar')
      let result = getreg(v:register)
      Assert Equals(result, 'foobar')
    End
  End

  Describe #open({uri})
    Before
      let scope = themis#helper('scope')
      let vars = scope.vars(Path.realpath('autoload/gina/util.vim'))

      function! vars.File.open(...) abort
        let self._open_called_with = a:000
      endfunction
    End

    It calls "System.File.open()" to open {uri} with a system browser
      call gina#util#open('https://github.com/lambdalisue/gina.vim')
      Assert Equals(
            \ vars.File._open_called_with,
            \ ['https://github.com/lambdalisue/gina.vim']
            \)
    End
  End

  Describe #filter({arglead} {candidates}[, {hidden_pattern}])
    Before
      let candidates = [
            \ 'f',
            \ 'fo',
            \ 'foo',
            \ 'foobar',
            \ 'bar',
            \ 'hoge',
            \]
    End

    It returns {candidates}
      let result = gina#util#filter('', candidates)
      Assert Equals(result, candidates)
    End

    It returns {candidates} except items which match with {hidden_pattern}
      let result = gina#util#filter('', candidates, 'bar')
      Assert Equals(result, [
            \ 'f',
            \ 'fo',
            \ 'foo',
            \ 'hoge',
            \])
    End

    It returns a partial {candidates} start from {arglead}
      let result = gina#util#filter('foo', candidates)
      Assert Equals(result, ['foo', 'foobar'])

      let result = gina#util#filter('b', candidates)
      Assert Equals(result, ['bar'])
    End

    It returns a partial {candidates} start {arglead}, ignore {hidden_pattern}
      let result = gina#util#filter('foo', candidates, 'bar')
      Assert Equals(result, ['foo', 'foobar'])
    End
  End

  Describe #shellescape({value}[, {prefix}])
    It returns an empty string for an empty {value}
      let result = gina#util#shellescape('')
      Assert Equals(result, '')

      let result = gina#util#shellescape('', '--prefix=')
      Assert Equals(result, '')
    End

    It returns a shellescaped {value} with {prefix}
      if s:is_windows
        let result = gina#util#shellescape('v a l u e')
        Assert Equals(result, '"v a l u e"')

        let result = gina#util#shellescape('v a l u e', '--prefix=')
        Assert Equals(result, '--prefix="v a l u e"')
      else
        let result = gina#util#shellescape('v a l u e')
        Assert Equals(result, '''v a l u e''')

        let result = gina#util#shellescape('v a l u e', '--prefix=')
        Assert Equals(result, '--prefix=''v a l u e''')
      endif
    End
  End

  Describe #fnameescape({value}[, {prefix}])
    It returns an empty string for an empty {value}
      let result = gina#util#fnameescape('')
      Assert Equals(result, '')

      let result = gina#util#fnameescape('', '--prefix=')
      Assert Equals(result, '')
    End

    It returns a fnameescaped {value} with {prefix}
      let result = gina#util#fnameescape('v a l u e')
      Assert Equals(result, 'v\ a\ l\ u\ e')

      let result = gina#util#fnameescape('v a l u e', '--prefix=')
      Assert Equals(result, '--prefix=v\ a\ l\ u\ e')
    End
  End

  Describe #params({expr})
    It returns an empty dictionary when {bufname} does not start from 'gina:'
      let params = gina#util#params('autoload/gina.vim')
      Assert Equals(params, {})
    End

    It returns a params dictionary for 'gina:gina.vim:status'
      let params = gina#util#params('gina:gina.vim:status')
      Assert Equals(params.repo, 'gina.vim')
      Assert Equals(params.scheme, 'status')
      Assert Equals(params.params, [])
      Assert Equals(params.commit, '')
      Assert Equals(params.path, '')
    End

    It returns a params dictionary for 'gina:gina.vim:commit:amend'
      let params = gina#util#params('gina:gina.vim:commit:amend')
      Assert Equals(params.repo, 'gina.vim')
      Assert Equals(params.scheme, 'commit')
      Assert Equals(params.params, ['amend'])
      Assert Equals(params.commit, '')
      Assert Equals(params.path, '')
    End

    It returns a params dictionary for 'gina:gina.vim:commit:ignore-submodule'
      let params = gina#util#params('gina:gina.vim:commit:amend:ignore-submodule')
      Assert Equals(params.repo, 'gina.vim')
      Assert Equals(params.scheme, 'commit')
      Assert Equals(params.params, ['amend', 'ignore-submodule'])
      Assert Equals(params.commit, '')
      Assert Equals(params.path, '')
    End

    It returns a params dictionary for 'gina:gina.vim:show/HEAD:README.md'
      let params = gina#util#params('gina:gina.vim:show/HEAD:README.md')
      Assert Equals(params.repo, 'gina.vim')
      Assert Equals(params.scheme, 'show')
      Assert Equals(params.params, [])
      Assert Equals(params.commit, 'HEAD')
      Assert Equals(params.path, 'README.md')
    End

    It returns a params dictionary for 'gina:gina.vim:show/:README.md'
      let params = gina#util#params('gina:gina.vim:show/:README.md')
      Assert Equals(params.repo, 'gina.vim')
      Assert Equals(params.scheme, 'show')
      Assert Equals(params.params, [])
      Assert Equals(params.commit, '')
      Assert Equals(params.path, 'README.md')
    End

    It returns a params dictionary for 'gina:gina.vim:show/HEAD'
      let params = gina#util#params('gina:gina.vim:show/HEAD')
      Assert Equals(params.repo, 'gina.vim')
      Assert Equals(params.scheme, 'show')
      Assert Equals(params.params, [])
      Assert Equals(params.commit, 'HEAD')
      Assert Equals(params.path, '')
    End
  End

  Describe #expand({expr})
    It returns an empty string for an empty {expr}
      let actual = gina#util#expand('')
      let expect = ''
      Assert Equals(actual, expect)
    End

    It returns a path when {expr} is a path
      let actual = gina#util#expand('autoload/gina.vim')
      let expect = Path.realpath('autoload/gina.vim')
      Assert Equals(actual, expect)
    End

    It returns an expanded path of current buffer when {expr} is '%'
      execute 'edit foobar'
      let actual = gina#util#expand('%')
      let expect = 'foobar'
      Assert Equals(actual, expect)

      let actual = gina#util#expand('%:p')
      let expect = fnamemodify('foobar', ':p')
      Assert Equals(actual, expect)
    End

    It returns a path of current buffer when {expr} is 'gina:...'
      execute 'edit gina:gina.vim:show/HEAD:README.md'
      let actual = gina#util#expand('%')
      let expect = 'README.md'
      Assert Equals(actual, expect)

      let actual = gina#util#expand('%:p')
      let expect = fnamemodify('README.md', ':p')
      Assert Equals(actual, expect)
    End
  End

  Describe #abspath({path})
    Before
      silent! windo bwipeout!
    End

    It returns an absolute {path} of the current path
      execute 'edit' fnameescape(g:git_profile.valid1)

      let git = gina#core#get()
      Assert Equals(
            \ gina#util#abspath(Path.realpath('A/foo/bar.txt')),
            \ Path.join(git.worktree, 'A', 'foo', 'bar.txt')
            \)
    End

    It returns an absolute {path} from cwd when the buffer is not in a git working tree
      execute 'edit' fnameescape(g:git_profile.invalid)
      let cwd = getcwd()

      Assert Equals(
            \ gina#util#abspath(Path.realpath('A/foo/bar.txt')),
            \ Path.join(cwd, 'A', 'foo', 'bar.txt')
            \)
    End
  End

  Describe #relpath({path})
    Before
      silent! windo bwipeout!
    End

    It returns a relative {path} of the current path
      execute 'edit' fnameescape(g:git_profile.valid1)

      let git = gina#core#get()
      let path = Path.join(git.worktree, 'A', 'foo', 'bar.txt')
      Assert Equals(
            \ gina#util#relpath(path),
            \ Path.realpath('A/foo/bar.txt')
            \)
    End

    It returns a relative {path} from cwd when the buffer is not in a git working tree
      execute 'edit' fnameescape(g:git_profile.invalid)

      let cwd = getcwd()
      let path = Path.join(cwd, 'A', 'foo', 'bar.txt')

      Assert Equals(
            \ gina#util#relpath(path),
            \ Path.realpath('A/foo/bar.txt')
            \)
    End
  End

  Describe #doautocmd({name}[, {pattern})
    After
      augroup gina_test_util_doautocmd
        autocmd! *
      augroup END
      silent! unlet g:gina_test_util_doautocmd
    End

    It calls {name} autocmd
      augroup gina_test_util_doautocmd
        autocmd! *
        autocmd BufReadPre * let g:gina_test_util_doautocmd = 1
      augroup END
      Assert False(exists('g:gina_test_util_doautocmd'))
      call gina#util#doautocmd('BufReadPre')
      Assert True(g:gina_test_util_doautocmd)
    End

    It calls {name} autocmd with {pattern}
      augroup gina_test_util_doautocmd
        autocmd! *
        autocmd User gina_test_util_doautocmd let g:gina_test_util_doautocmd = 1
      augroup END
      Assert False(exists('g:gina_test_util_doautocmd'))
      call gina#util#doautocmd('User', 'gina_test_util_doautocmd')
      Assert True(g:gina_test_util_doautocmd)
    End

    It does not show 'No matching autocommands' warning even the {name} autocmd is not registered
      augroup gina_test_util_doautocmd
        autocmd! *
        autocmd BufReadPre foo:* let g:gina_test_util_doautocmd = 1
      augroup END
      " exists('#BufReadPre') returns 1 while BufReadPre foo:* is registered
      Assert True(exists('#BufReadPre'))
      " But a builtin doautocmd shows 'No matching autocommands' warning while
      " a current buffer does not match with the registered pattern.
      try
        redir => content
        doautocmd BufReadPre
      finally
        redir END
      endtry
      Assert Equals(split(content, "\n"), ['No matching autocommands'])
      " But gina#util#doautocmd does not call autocmd in this case
      try
        redir => content
        call gina#util#doautocmd('BufReadPre')
      finally
        redir END
      endtry
      Assert Equals(split(content, "\n"), [])
      " The registered autocmd should not be called
      Assert False(exists('g:gina_test_util_doautocmd'))
    End
  End

  Describe #syncbind()
    It calls a "syncbind" command a bit later
      " NO TEST
    End
  End

  Describe #diffthis()
    It adds autocmd to call "diffoff" when a buffer is closed
      call gina#util#diffthis()
      Assert True(exists('#gina_internal_util_diffthis'))
    End
  End

  Describe #diffupdate()
    It calls a "diffupdate" command a bit later
      " NO TEST
    End
  End

  Describe #map({mode}, {lhs}, {rhs})
    Before
      windo bwipeout!
    End

    It execute "map" of {mode} with <buffer> when there is no mapping for {lhs} -> {rhs}
      Assert False(hasmapto('\ABCdoit', 'n'))
      Assert False(hasmapto('\ABCdoit', 'i'))
      Assert False(hasmapto('\ABCdoit', 'v'))
      Assert Equals(maparg('<Leader>d', 'n'), '')
      Assert Equals(maparg('<Leader>d', 'i'), '')
      Assert Equals(maparg('<Leader>d', 'v'), '')

      call gina#util#map('n', '<Leader>d', '\ABCdoit')
      Assert True(hasmapto('\ABCdoit', 'n'))
      Assert False(hasmapto('\ABCdoit', 'i'))
      Assert False(hasmapto('\ABCdoit', 'v'))
      Assert Equals(maparg('<Leader>d', 'n'), '\ABCdoit')
      Assert Equals(maparg('<Leader>d', 'i'), '')
      Assert Equals(maparg('<Leader>d', 'v'), '')

      call gina#util#map('iv', '<Leader>d', '\ABCdoit')
      Assert True(hasmapto('\ABCdoit', 'n'))
      Assert True(hasmapto('\ABCdoit', 'i'))
      Assert True(hasmapto('\ABCdoit', 'v'))
      Assert Equals(maparg('<Leader>d', 'n'), '\ABCdoit')
      Assert Equals(maparg('<Leader>d', 'i'), '\ABCdoit')
      Assert Equals(maparg('<Leader>d', 'v'), '\ABCdoit')

      call gina#util#map('n', '<Leader>e', '\ABCdoit')
      Assert True(hasmapto('\ABCdoit', 'n'))
      Assert True(hasmapto('\ABCdoit', 'i'))
      Assert True(hasmapto('\ABCdoit', 'v'))
      Assert Equals(maparg('<Leader>d', 'n'), '\ABCdoit')
      Assert Equals(maparg('<Leader>d', 'i'), '\ABCdoit')
      Assert Equals(maparg('<Leader>d', 'v'), '\ABCdoit')
      Assert Equals(maparg('<Leader>e', 'n'), '')
    End
  End

  Describe #nmap({lhs}, {rhs})
    Before
      windo bwipeout!
    End

    It execute "nmap" with <buffer> when there is no mapping for {lhs} -> {rhs}
      Assert False(hasmapto('\ABCdoit', 'n'))
      Assert Equals(maparg('<Leader>d', 'n'), '')
      Assert Equals(maparg('<Leader>e', 'n'), '')

      call gina#util#nmap('<Leader>d', '\ABCdoit')
      Assert True(hasmapto('\ABCdoit', 'n'))
      Assert Equals(maparg('<Leader>d', 'n'), '\ABCdoit')
      Assert Equals(maparg('<Leader>e', 'n'), '')

      call gina#util#nmap('<Leader>e', '\ABCdoit')
      Assert True(hasmapto('\ABCdoit', 'n'))
      Assert Equals(maparg('<Leader>d', 'n'), '\ABCdoit')
      Assert Equals(maparg('<Leader>e', 'n'), '')
    End
  End

  Describe #imap({lhs}, {rhs})
    Before
      windo bwipeout!
    End

    It execute "imap" with <buffer> when there is no mapping for {lhs} -> {rhs}
      Assert False(hasmapto('\ABCdoit', 'i'))
      Assert Equals(maparg('<Leader>d', 'i'), '')
      Assert Equals(maparg('<Leader>e', 'i'), '')

      call gina#util#imap('<Leader>d', '\ABCdoit')
      Assert True(hasmapto('\ABCdoit', 'i'))
      Assert Equals(maparg('<Leader>d', 'i'), '\ABCdoit')
      Assert Equals(maparg('<Leader>e', 'i'), '')

      call gina#util#imap('<Leader>e', '\ABCdoit')
      Assert True(hasmapto('\ABCdoit', 'i'))
      Assert Equals(maparg('<Leader>d', 'i'), '\ABCdoit')
      Assert Equals(maparg('<Leader>e', 'i'), '')
    End
  End

  Describe #vmap({lhs}, {rhs})
    Before
      windo bwipeout!
    End

    It execute "vmap" with <buffer> when there is no mapping for {lhs} -> {rhs}
      Assert False(hasmapto('\ABCdoit', 'v'))
      Assert Equals(maparg('<Leader>d', 'v'), '')
      Assert Equals(maparg('<Leader>e', 'v'), '')

      call gina#util#vmap('<Leader>d', '\ABCdoit')
      Assert True(hasmapto('\ABCdoit', 'v'))
      Assert Equals(maparg('<Leader>d', 'v'), '\ABCdoit')
      Assert Equals(maparg('<Leader>e', 'v'), '')

      call gina#util#vmap('<Leader>e', '\ABCdoit')
      Assert True(hasmapto('\ABCdoit', 'v'))
      Assert Equals(maparg('<Leader>d', 'v'), '\ABCdoit')
      Assert Equals(maparg('<Leader>e', 'v'), '')
    End
  End
End
