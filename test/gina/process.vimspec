Describe gina#process
  Before all
    let Path = vital#gina#import('System.Filepath')
    let slit1 = Slit(tempname(), 1)
    call slit1.write('A/foo.txt', [])
    call slit1.write('B/foo.txt', [])
    call slit1.write('C/foo.txt', [])

    call slit1.execute('add %s', slit1.path('A/foo.txt'))
    call slit1.execute('commit --quiet -m "First"')
    call slit1.execute('checkout -b develop')
    call slit1.execute('add %s', slit1.path('B/foo.txt'))
    call slit1.execute('commit --quiet -m "Second"')
    call slit1.execute('checkout master')
    call slit1.execute('add %s', slit1.path('C/foo.txt'))
    call slit1.execute('commit --quiet -m "Thrid"')
  End

  Before
    silent! bufdo bwipeout!
  End

  Describe #open({git}, {args} [, {options}])
    Before
      let options = {'stdout': [], 'stderr': []}

      function! options.on_stdout(job, msg, event) abort
        call extend(self.stdout, a:msg)
      endfunction

      function! options.on_stderr(job, msg, event) abort
        call extend(self.stderr, a:msg)
      endfunction
    End

    It opens an {args} of {git} and returns a job instance
      execute 'edit' fnameescape(slit1.worktree)
      let git = gina#core#get()
      let job = gina#process#open(git, ['branch'], options)
      call job.wait()
      Assert Equals(job.stdout, ['  develop', '* master', ''])
      Assert Equals(job.stderr, [])
    End
  End

  Describe #call({git}, {args} [, {options}])
    It calls an {args} of {git} and returns a result instance
      execute 'edit' fnameescape(slit1.worktree)
      let git = gina#core#get()
      let result = gina#process#call(git, ['branch'])
      Assert Equals(result.status, 0)
      Assert Equals(result.stdout, ['  develop', '* master'])
      Assert Equals(result.stderr, [])
      Assert Equals(result.content, ['  develop', '* master'])
    End
  End

  Describe #exec({git}, {args})
    Before
      let tracker = {
            \ 'command_called_called_count': 0,
            \ 'command_called_args': [],
            \}

      function! tracker.command_called(...) abort
        let self.command_called_called_count += 1
        let self.command_called_args = a:000
      endfunction

      call gina#core#emitter#subscribe(
            \ 'command:called',
            \ tracker.command_called, tracker,
            \)
    End

    After
      call gina#core#emitter#unsubscribe(
            \ 'command:called',
            \ tracker.command_called, tracker,
            \)
    End

    It calls an {args} of {git} and assign the result content into the current buffer
      execute 'edit' fnameescape(slit1.worktree)
      let git = gina#core#get()
      let args = gina#command#parse_args(['branch'])
      call gina#process#exec(git, args)
      Assert Equals(getline(1, '$'), [''])
      call gina#process#wait()
      Assert Equals(getline(1, '$'), ['  develop', '* master'])
    End

    It emits 'command:called' event with a command scheme
      execute 'edit' fnameescape(slit1.worktree)
      let git = gina#core#get()
      let args = gina#command#parse_args(['branch'])
      call gina#process#exec(git, args)
      Assert Equals(tracker.command_called_called_count, 0)
      Assert Equals(tracker.command_called_args, [])
      call gina#process#wait()
      Assert Equals(tracker.command_called_called_count, 1)
      Assert Equals(tracker.command_called_args, ['branch'])
    End
  End

  Describe #inform({result})
    It shows a result content when success
      execute 'edit' fnameescape(slit1.worktree)
      let git = gina#core#get()
      let result = gina#process#call(git, ['branch'])
      let output = split(execute('call gina#process#inform(result)'), '\r\?\n')
      Assert Equals(output, [
            \ '[gina]   develop',
            \ '[gina] * master',
            \])
    End

    It shows an args as well when fail
      execute 'edit' fnameescape(slit1.worktree)
      let git = gina#core#get()
      let result = gina#process#call(git, ['unknown-command'])
      let output = split(execute('call gina#process#inform(result)'), '\r\?\n')
      Assert Match(output[0], '^\[gina\] Fail:.* git .* unknown-command$')
      Assert Equals(output[1], '[gina] git: ''unknown-command'' is not a git command. See ''git --help''.')
    End
  End

  Describe #error({result})
    It returns an error message for the {result}
      execute 'edit' fnameescape(slit1.worktree)
      let git = gina#core#get()
      let result = gina#process#call(git, ['unknown-command'])
      let output = split(gina#process#error(result), '\r\?\n')
      Assert Match(output[0], '^vital: Vim.Exception: Error: Fail:.* git .* unknown-command$')
      Assert Equals(output[1], 'git: ''unknown-command'' is not a git command. See ''git --help''.')
    End
  End
End
