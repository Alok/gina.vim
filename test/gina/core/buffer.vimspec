Describe gina#core#buffer
  Before all
    let Path = vital#gina#import('System.Filepath')
    let is_windows = has('win32') || has('win64')
  End

  Before
    bufdo! bwipeout!
  End

  Describe #bufname({git}, {scheme} [, {options}])
    Before
      let git = {'refname': 'valid'}
    End

    It returns a shortest path for the specified params
      Assert Equals(gina#core#buffer#bufname(git, 'status'), 'gina://valid:status')
      Assert Equals(gina#core#buffer#bufname(git, 'commit', {
            \ 'params': ['amend'],
            \}),
            \'gina://valid:commit:amend'
            \)
      Assert Equals(gina#core#buffer#bufname(git, 'show', {
            \ 'relpath': 'README.md',
            \}),
            \'gina://valid:show/:README.md'
            \)
      Assert Equals(gina#core#buffer#bufname(git, 'diff', {
            \ 'revision': 'origin/HEAD',
            \ 'relpath': 'README.md',
            \}),
            \'gina://valid:diff/origin/HEAD:README.md'
            \)
      Assert Equals(gina#core#buffer#bufname(git, 'changes', {
            \ 'revision': 'origin/HEAD...',
            \}),
            \'gina://valid:changes/origin/HEAD...'
            \)

    End

    It returns an Unix-like path (separate with '/' rather than '\') always
      Assert Equals(gina#core#buffer#bufname(git, 'show', {
            \ 'relpath': 'autoload\gina\core.vim',
            \}),
            \'gina://valid:show/:autoload/gina/core.vim'
            \)
      Assert Equals(gina#core#buffer#bufname(git, 'diff', {
            \ 'revision': 'origin/HEAD',
            \ 'relpath': 'autoload\gina\core.vim',
            \}),
            \'gina://valid:diff/origin/HEAD:autoload/gina/core.vim'
            \)
    End
  End

  Describe #parse({expr})
    Before
      let git = {'refname': 'valid'}
    End

    It returns an empty dictionary when {expr} is not built by gina#core#buffer#bufname()
      Assert Equals(gina#core#buffer#parse('README.md'), {})
      Assert Equals(gina#core#buffer#parse('autoload/gina/core.vim'), {})
    End

    It returns params of {expr} which has built by gina#core#buffer#bufname()
      Assert Equals(gina#core#buffer#parse('gina://valid:status'), {
            \ 'repo': 'valid',
            \ 'scheme': 'status',
            \ 'params': [],
            \ 'revision': '',
            \ 'relpath': '',
            \})
      Assert Equals(gina#core#buffer#parse('gina://valid:commit:amend'), {
            \ 'repo': 'valid',
            \ 'scheme': 'commit',
            \ 'params': ['amend'],
            \ 'revision': '',
            \ 'relpath': '',
            \})
      Assert Equals(gina#core#buffer#parse('gina://valid:show/:README.md'), {
            \ 'repo': 'valid',
            \ 'scheme': 'show',
            \ 'params': [],
            \ 'revision': '',
            \ 'relpath': 'README.md',
            \})
      Assert Equals(gina#core#buffer#parse('gina://valid:diff/origin/HEAD:README.md'), {
            \ 'repo': 'valid',
            \ 'scheme': 'diff',
            \ 'params': [],
            \ 'revision': 'origin/HEAD',
            \ 'relpath': 'README.md',
            \})
      Assert Equals(gina#core#buffer#parse('gina://valid:changes/origin/HEAD...'), {
            \ 'repo': 'valid',
            \ 'scheme': 'changes',
            \ 'params': [],
            \ 'revision': 'origin/HEAD...',
            \ 'relpath': '',
            \})
      Assert Equals(gina#core#buffer#parse('gina://valid:show/:3:README.md'), {
            \ 'repo': 'valid',
            \ 'scheme': 'show',
            \ 'params': [],
            \ 'revision': ':3',
            \ 'relpath': 'README.md',
            \})
    End

    It returns params of {expr} which has built by gina#core#buffer#bufname()
      execute 'edit' 'gina://valid:status'
      Assert Equals(gina#core#buffer#parse('%'), {
            \ 'repo': 'valid',
            \ 'scheme': 'status',
            \ 'params': [],
            \ 'revision': '',
            \ 'relpath': '',
            \})
    End
  End

  Describe #param({expr}, {attr} [, {default}])
    It throws an exception when unknown {attr} has specified
      Throws /Unknown attribute/ gina#core#buffer#param('gina://valid:status', 'path')
    End

    It returns a value of an {attr} in params of {expr}
      Assert Equals(gina#core#buffer#param('gina://valid:status', 'repo'), 'valid')
      Assert Equals(gina#core#buffer#param('gina://valid:status', 'scheme'), 'status')
      Assert Equals(gina#core#buffer#param('gina://valid:commit:amend', 'params'), ['amend'])
      Assert Equals(gina#core#buffer#param('gina://valid:show/:README.md', 'relpath'), 'README.md')
      Assert Equals(gina#core#buffer#param('gina://valid:diff/origin/HEAD:README.md', 'revision'), 'origin/HEAD')
      Assert Equals(gina#core#buffer#param('gina://valid:changes/origin/HEAD...', 'revision'), 'origin/HEAD...')
    End

    It returns a correct default value of an {attr} when {expr} is invalid
      Assert Equals(gina#core#buffer#param('README.md', 'repo'), '')
      Assert Equals(gina#core#buffer#param('README.md', 'scheme'), '')
      Assert Equals(gina#core#buffer#param('README.md', 'params'), [])
      Assert Equals(gina#core#buffer#param('README.md', 'revision'), '')
      Assert Equals(gina#core#buffer#param('README.md', 'relpath'), '')
    End

    It returns a specified default value of an {attr} when {expr} is invalid
      Assert Equals(gina#core#buffer#param('README.md', 'repo', 'foo'), 'foo')
      Assert Equals(gina#core#buffer#param('README.md', 'scheme', 'foo'), 'foo')
      Assert Equals(gina#core#buffer#param('README.md', 'params', 'foo'), 'foo')
      Assert Equals(gina#core#buffer#param('README.md', 'revision', 'foo'), 'foo')
      Assert Equals(gina#core#buffer#param('README.md', 'relpath', 'foo'), 'foo')
    End
  End

  Describe #open({bufname}, [, {options}])
    Before
      bufdo! bwipeout!
    End

    It opens a new {bufname} buffer and return an informatio context
      edit foo1
      new foo2
      let context = gina#core#buffer#open('foo3')
      Assert Equals(winnr('$'), 2)
      Assert Equals(bufname('%'), 'foo3')
      Assert KeyExists(context, 'bufexists')
      Assert KeyExists(context, 'bufloaded')
      Assert KeyExists(context, 'bufname')
      Assert KeyExists(context, 'bufnr')
      Assert KeyExists(context, 'preview')
      Assert Equals(context.bufexists, 0)
      Assert Equals(context.bufloaded, 0)
      Assert Equals(context.bufname, 'foo3')
      Assert Equals(context.bufnr, bufnr('%'))
      Assert Equals(context.preview, 0)
    End

    It focus a {bufname} buffer when exist and return an informatio context
      edit foo1
      new foo2
      let context = gina#core#buffer#open('foo1')
      Assert Equals(winnr('$'), 2)
      Assert Equals(bufname('%'), 'foo1')
      Assert KeyExists(context, 'bufexists')
      Assert KeyExists(context, 'bufloaded')
      Assert KeyExists(context, 'bufname')
      Assert KeyExists(context, 'bufnr')
      Assert KeyExists(context, 'preview')
      Assert Equals(context.bufexists, 1)
      Assert Equals(context.bufloaded, 1)
      Assert Equals(context.bufname, 'foo1')
      Assert Equals(context.bufnr, bufnr('%'))
      Assert Equals(context.preview, 0)
    End

    Context Buffer name normalization
      It remove leading/trailing whitespaces in {bufname}
        let context = gina#core#buffer#open('  foo  ')
        Assert Equals(bufname('%'), 'foo')
      End

      It remove trailing : in {bufname}
        let context = gina#core#buffer#open('foo:::')
        Assert Equals(bufname('%'), 'foo')
      End

      It remove trailing / in {bufname}
        let context = gina#core#buffer#open('foo///')
        Assert Equals(bufname('%'), 'foo')
      End

      It remove trailing \ in {bufname}
        let context = gina#core#buffer#open('foo\\\')
        Assert Equals(bufname('%'), 'foo')
      End

      It recursively remove aboves
        let context = gina#core#buffer#open(' foo :/\ :/\ :/\')
        Assert Equals(bufname('%'), 'foo')
      End
    End

    Context Anchoring before open
      It does not moves focus before opening a new {bufname} if a current window is suitable for opening a buffer
        edit foo1
        new foo2
        let context = gina#core#buffer#open('foo3')
        Assert Equals(winnr('$'), 2)
        Assert Equals(bufname(winbufnr(1)), 'foo3')
        Assert Equals(bufname(winbufnr(2)), 'foo1')
      End

      It moves focus before opening a new {bufname} if a current window is not suitable for opening a buffer
        edit foo1
        new foo2 | setlocal buftype=nofile
        let context = gina#core#buffer#open('foo3')
        Assert Equals(winnr('$'), 2)
        Assert Equals(bufname(winbufnr(1)), 'foo2')
        Assert Equals(bufname(winbufnr(2)), 'foo3')
      End
    End

    Context {options.mod}
      It opens a new {bufname} with respecting {options.mods}
        edit foo1
        let options = {'opener': 'split'}
        call gina#core#buffer#open('foo2', options)
        Assert Equals(bufname(winbufnr(1)), 'foo2')
        Assert Equals(bufname(winbufnr(2)), 'foo1')

        let options.mods = 'botright'
        call gina#core#buffer#open('foo3', options)
        Assert Equals(bufname(winbufnr(1)), 'foo2')
        Assert Equals(bufname(winbufnr(2)), 'foo1')
        Assert Equals(bufname(winbufnr(3)), 'foo3')
      End
    End

    Context {options.opener}
      It opens a new {bufname} buffer with {options.opener}
        edit foo1
        call gina#core#buffer#open('foo2')
        Assert Equals(winnr('$'), 1)
        Assert Equals(bufname(winbufnr(1)), 'foo2')

        let options = {'opener': 'split'}
        call gina#core#buffer#open('foo3', options)
        Assert Equals(winnr('$'), 2)
        Assert Equals(bufname(winbufnr(1)), 'foo3')
        Assert Equals(bufname(winbufnr(2)), 'foo2')

        let options = {'opener': 'botright split'}
        call gina#core#buffer#open('foo4', options)
        Assert Equals(winnr('$'), 3)
        Assert Equals(bufname(winbufnr(1)), 'foo3')
        Assert Equals(bufname(winbufnr(2)), 'foo2')
        Assert Equals(bufname(winbufnr(3)), 'foo4')
      End
    End

    Context {options.cmdarg}
      It opens a new {bufname} with {cmdarg}
        call gina#core#buffer#open('foo', {
              \ 'cmdarg': '++enc=sjis ++ff=mac'
              \})
        Assert Equals(&fileencoding, 'sjis')
        Assert Equals(&fileformat, 'mac')
      End

      It focus a new {bufname} with {cmdarg}
        edit foo
        Assert Equals(&fileencoding, '')
        Assert Equals(&fileformat, is_windows ? 'dos' : 'unix')

        call gina#core#buffer#open('foo', {
              \ 'cmdarg': '++enc=sjis ++ff=mac'
              \})
        Assert Equals(&fileencoding, 'sjis')
        Assert Equals(&fileformat, 'mac')
      End

      It opens a new {bufname} with {cmdarg} with {group}
        call gina#core#buffer#open('foo', {
              \ 'group': 'short',
              \ 'cmdarg': '++enc=sjis ++ff=mac'
              \})
        Assert Equals(&fileencoding, 'sjis')
        Assert Equals(&fileformat, 'mac')
      End

      It focus a new {bufname} with {cmdarg} with {group}
        call gina#core#buffer#open('foo', {
              \ 'group': 'short',
              \})
        Assert Equals(&fileencoding, '')
        Assert Equals(&fileformat, is_windows ? 'dos' : 'unix')

        call gina#core#buffer#open('foo', {
              \ 'group': 'short',
              \ 'cmdarg': '++enc=sjis ++ff=mac'
              \})
        Assert Equals(&fileencoding, 'sjis')
        Assert Equals(&fileformat, 'mac')
      End
    End

    Context {options.callback}
      It throws an exception if a content of the buffer has modified by callback function
        let callback = {}

        function! callback.fn() abort
          call append(0, ['This should not be allowed.'])
        endfunction

        Throws /A buffer content could not be modified by callback/
              \ gina#core#buffer#open('foo', {'callback': callback})
      End

      It calls a callback funcion on a opened buffer in any case
        let options = {}
        let options.callback = {}
        function! options.callback.fn() abort
          let b:gina_core_buffer_called = 1
        endfunction

        let context = gina#core#buffer#open('foo1', options)
        Assert Equals(bufnr('%'), context.bufnr)
        Assert Equals(getbufvar(context.bufnr, 'gina_core_buffer_called'), 1)

        let options.opener = 'pedit'
        let context = gina#core#buffer#open('foo2', options)
        Assert NotEquals(bufnr('%'), context.bufnr)
        Assert Equals(getbufvar(context.bufnr, 'gina_core_buffer_called'), 1)
      End

      It calls a callback function on a focused buffer in any case
        edit foo1
        new foo2

        let options = {}
        let options.callback = {}
        function! options.callback.fn() abort
          let b:gina_core_buffer_called = 1
        endfunction

        let context = gina#core#buffer#open('foo1', options)
        Assert Equals(bufnr('%'), context.bufnr)
        Assert Equals(getbufvar(context.bufnr, 'gina_core_buffer_called'), 1)
        bwipeout!
      End

      It calls a callback with {args}
        let options = {}
        let options.callback = {}
        function! options.callback.fn(...) abort
          let b:gina_core_buffer_called = a:000
        endfunction

        let options.callback.args = ['foo', 'bar']
        let context = gina#core#buffer#open('foo1', options)
        Assert Equals(b:gina_core_buffer_called, ['foo', 'bar'])
      End
    End

    Context {options.group}
      It reuses an opend window which opens a buffer with same {options.group}
        edit foo1
        call gina#core#buffer#open('foo2', {
              \ 'opener': 'split',
              \ 'group': 'short',
              \})
        Assert Equals(winnr('$'), 2)
        Assert Equals(bufname(winbufnr(1)), 'foo2')
        Assert Equals(bufname(winbufnr(2)), 'foo1')

        call gina#core#buffer#open('foo3', {
              \ 'opener': 'split',
              \ 'group': 'short',
              \})
        Assert Equals(winnr('$'), 2)
        Assert Equals(bufname(winbufnr(1)), 'foo3')
        Assert Equals(bufname(winbufnr(2)), 'foo1')
      End
    End
  End

  Describe #focus({expr})
    " NOTE:
    " This feature is already tested in Vital.Vim.Window
  End

  Describe #assign_content({content})
    It assign {content} to the current buffer without modifing marks
      call setline(1, ['a', 'b', 'c', 'd', 'e'])
      normal! gg
      normal ma
      normal jmb
      normal jmc
      normal jmd
      normal jme
      Assert Equals(len(split(execute('marks abcde'), '\r\?\n')), 5 + 1)

      call gina#core#buffer#assign_content(['A', 'B', 'C', 'D', 'E'])
      Assert Equals(len(split(execute('marks abcde'), '\r\?\n')), 5 + 1)
    End
  End

  Describe #extend_content({content})
    It extends a content of the current buffer with {content} without modifing marks
      call setline(1, ['a', 'b', 'c', 'd', 'e'])
      normal! gg
      normal ma
      normal jmb
      normal jmc
      normal jmd
      normal jme
      Assert Equals(len(split(execute('marks abcde'), '\r\?\n')), 5 + 1)

      call gina#core#buffer#extend_content(['A', 'B', 'C', 'D', 'E'])
      Assert Equals(getline(1, '$'), [
            \ 'a', 'b', 'c', 'd',
            \ 'eA',
            \ 'B', 'C', 'D', 'E',
            \])
      Assert Equals(len(split(execute('marks abcde'), '\r\?\n')), 5 + 1)
    End
  End
End
