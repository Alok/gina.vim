Describe gina#core#repo
  Before
    let Path = vital#gina#import('System.Filepath')
    silent! windo bwipeout!
  End

  Describe #expand({expr})
    It returns an empty string for an empty {expr}
      let actual = gina#core#repo#expand('')
      let expect = ''
      Assert Equals(actual, expect)
    End

    It returns a path when {expr} is a path
      let actual = gina#core#repo#expand('autoload/gina.vim')
      let expect = Path.realpath('autoload/gina.vim')
      Assert Equals(actual, expect)
    End

    It returns an expanded path of current buffer when {expr} is '%'
      execute 'edit foobar'
      let actual = gina#core#repo#expand('%')
      let expect = 'foobar'
      Assert Equals(actual, expect)

      let actual = gina#core#repo#expand('%:p')
      let expect = fnamemodify('foobar', ':p')
      Assert Equals(actual, expect)
    End

    It returns a path of current buffer when {expr} is 'gina:...'
      execute 'edit gina://gina.vim:show/HEAD:README.md'
      let actual = gina#core#repo#expand('%')
      let expect = 'README.md'
      Assert Equals(actual, expect)

      let actual = gina#core#repo#expand('%:p')
      let expect = fnamemodify('README.md', ':p')
      Assert Equals(actual, expect)
    End
  End

  Describe #abspath({git}, {path})
    It returns an absolute {path} of {git} working-tree
      execute 'edit' fnameescape(g:git_profile.valid1)

      let git = gina#core#get()
      Assert Equals(
            \ gina#core#repo#abspath(git, Path.realpath('A/foo/bar.txt')),
            \ Path.join(git.worktree, 'A', 'foo', 'bar.txt')
            \)
    End

    It returns an absolute {path} of cwd when {git} is empty
      execute 'edit' fnameescape(g:git_profile.invalid)
      let cwd = getcwd()
      let git = {}

      Assert Equals(
            \ gina#core#repo#abspath(git, Path.realpath('A/foo/bar.txt')),
            \ Path.join(cwd, 'A', 'foo', 'bar.txt')
            \)
    End
  End

  Describe #relpath({git}, {path})
    It returns a relative {path} from {git} working-tree
      execute 'edit' fnameescape(g:git_profile.valid1)

      let git = gina#core#get()
      let path = Path.join(git.worktree, 'A', 'foo', 'bar.txt')
      Assert Equals(
            \ gina#core#repo#relpath(git, path),
            \ Path.realpath('A/foo/bar.txt')
            \)
    End

    It returns a relative {path} from cwd when {git} is empty
      execute 'edit' fnameescape(g:git_profile.invalid)

      let cwd = getcwd()
      let git = {}
      let path = Path.join(cwd, 'A', 'foo', 'bar.txt')

      Assert Equals(
            \ gina#core#repo#relpath(git, path),
            \ Path.realpath('A/foo/bar.txt')
            \)
    End
  End

  Describe #path({git}, {path})
    It returns an expanded unix-style relative {path} from {git} working-tree
      let path = Path.join(g:git_profile.valid1, 'A', 'foo', 'bar.txt')
      execute 'edit' fnameescape(path)

      let git = gina#core#get()
      Assert Equals(
            \ gina#core#repo#path(git, '%'),
            \ Path.unixpath('A/foo/bar.txt')
            \)
    End
  End

  Describe #config({git})
    It returns a config dictionary of {git} repository
      execute 'edit' fnameescape(g:git_profile.valid1)

      let git = gina#core#get()
      let config = gina#core#repo#config(git)
      Assert KeyExists(config, 'branch')
      Assert KeyExists(config.branch, 'develop')
      Assert KeyExists(config.branch, 'ext/master')
    End
  End
End
