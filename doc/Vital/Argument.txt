*Vital/Argument.txt*			An argument manipulation library

Version: 0.1.0-dev
Author : Alisue <lambdalisue@hashnote.net>
License: MIT license
Support: Vim 7.4.2137 and above
Support: Neovim 0.1.7 and above


=============================================================================
CONTENTS					*Vital.Argument-content*

INTRODUCTION					|Vital.Argument-introduction|
  DEFINITION					|Vital.Argument-definition|
INTERFACE					|Vital.Argument-interface|
  FUNCTIONS					|Vital.Argument-functions|
  INSTANCE					|Vital.Argument-instance|


=============================================================================
INTRODUCTION					*Vital.Argument-introduction*

*Vital.Argument* is a |Vital| module used for parsing a command-line argument.

See also:

  Vital.OptionParser
  https://github.com/vim-jp/vital.vim

  Vital.ArgumentParser
  https://github.com/lambdalisue/vital-ArgumentParser


-----------------------------------------------------------------------------
DEFINITION					*Vital.Argument-definition*

The followings are the definition of the words used in this library.

Name		Definition~
term		Individual item of the argument
effective	Terms before "--"
residual	Terms after "--"
optional	Terms which starts from -\w or --\w in "effective"
positional	Terms which does not starts from -\w nor --\w in "effective"
>
In short, each names are defined as the following scheme:
>
                 effective                   residual
                     ▲                           ▲
        ┌────────────┴───────────┐    ┌──────────┴──────────┐
        │                        │    │                     │
	-f  mayuri --foo christina -- -h  rukako  steins;gate
	┈┈  ┈┈┈┈┈  ┈┈┈┈┈ ┈┈┈┈┈┈┈┈┈    ┈┈  ┈┈┈┈┈┈  ┈┈┈┈┈┈┈┈┈┈┈ ─▶ term
	 │    │      │         │ 
	 └─┬──│──────┘         │ 
           ▼  └────────┬───────┘ 
        optional       ▼
                   positional
<
=============================================================================
INTERFACE					*Vital.Argument-interface*

-----------------------------------------------------------------------------
FUNCTIONS       				*Vital.Argument-functions*

						*Vital.Argument.parse()*
parse({cmdline})
	Parses a {cmdline} and returns a term list.
>
	echo Argument.parse('foo')
	" -> ['foo']
	echo Argument.parse('foo bar')
	" -> ['foo', 'bar']
	echo Argument.parse('"foo foo" "bar bar"')
	" -> ['foo foo', 'bar bar']
	echo Argument.parse('foo "bar bar" hoge')
	" -> ['foo', 'bar bar', 'hoge']
	echo Argument.parse('--foo="foo" -b"bar"')
	" -> ['--foo=foo', '-bbar']
	echo Argument.parse('foo\ bar\ hoge')
	" -> ['foo\ bar\ hoge']
<
						*Vital.Argument.norm()*
norm({terms})
	Normalize a {terms} list and return.
>
	echo Argument.norm(['foo'])
	" -> ['foo']
	echo Argument.norm(['foo', 'bar'])
	" -> ['foo', 'bar']
	echo Argument.norm(['"foo foo"', '"bar bar"'])
	" -> ['foo foo', 'bar bar']
	echo Argument.norm(['foo', '"bar bar"', 'hoge'])
	" -> ['foo', 'bar bar', 'hoge']
	echo Argument.norm(['--foo="foo"', '-b"bar"'])
	" -> ['--foo=foo', '-bbar']
	echo Argument.norm(['foo\ bar\ hoge'])
	" -> ['foo\ bar\ hoge']
<
						*Vital.Argument.new()*
new([{init}])
	Returns a new args instance which has initialized with {init}.
	When |List| is specified to {init}, the list is used as a term list
	after normalize by |Vital.Argument.norm()|.
	When |String| is specified to {init}, the string is parsed by
	|Vital.Argument.parse()| and a result list is used as a term list.
	See |Vital.Argument-instance| for the instance detail.


-----------------------------------------------------------------------------
INSTANCE					*Vital.Argument-instance*

					*Vital.Argument-args.raw*
args.raw
	A raw list. When a complex operation is required, modify this list
	directly.

					*Vital.Argument-args.hash()*
args.hash()
	Return a unique |sha256| string of the instance.

					*Vital.Argument-args.lock()*
args.lock()
	Locks the instance by |:lockvar|.

					*Vital.Argument-args.clone()*
args.clone()
	Copies and return a new instance from the instance.
	It automatically unlock the instance.
	Note that user defined attributes are not copied so use |deepcopy()|
	instead if you need that.

					*Vital.Argument-args.index()*
args.index({query})
	Return an index of an optional/positional term by the {query}.
	When a {query} is a string, an optional term which match with the
	{query} will be returned.
	When a {query} is a positive number, a ({query} + 1)-th positonal
	term will be returned.
	It returns -1 when no maching term is found and it throws an
	exception when a negative value is specified to the {query}.
>
	let args = Argument.new([
	      \ '--foo', 'foo',
	      \ '--bar', 'bar',
	      \ '--',
	      \ '--wow', 'wow',
	      \])
	echo args.index('-f|--foo')
	" -> 0
	echo args.index('-b|--bar')
	" -> 2
	echo args.index('-w|--wow')
	" -> -1
	echo args.index(0)
	" -> 1
	echo args.index(1)
	" -> 3
	echo args.index(2)
	" -> -1
<
					*Vital.Argument-args.has()*
args.has({query})
	Returns 1 if a term is found for {query}. Otherwise 0.

					*Vital.Argument-args.get()*
args.get({query} [, {default}])
	Returns a value of a first term found for {query}.
	It returns {default} if no term is found.
>
	let args = Argument.new([
	      \ '--foo', 'foo',
	      \ '--bar', 'bar',
	      \ '--',
	      \ '--wow', 'wow',
	      \])
	echo args.get('-f|--foo')
	" -> 1
	echo args.get('-b|--bar')
	" -> 'bar'
	echo args.get('-w|--wow')
	" -> 0
	echo args.get('-w|--wow', '')
	" -> ''
	echo args.get(1)
	" -> 'foo'
	echo args.get(2)
	" -> 'bar'
	echo args.get(3)
	" -> ''
	echo args.get(3, 0)
	" -> 0
<
					*Vital.Argument-args.pop()*
args.pop({query} [, {default}])
	Returns a value of a first term found for {query} and remove.
	It returns {default} if no term is found.
>
	let args = Argument.new(['--foo', '-f', '--bar=bar', '-bBAR'])
	echo args.pop('-b|--bar')
	" -> 'bar'
	echo args.raw
	" -> ['--foo', '-f', '-bBAR']
<
					*Vital.Argument-args.set()*
args.set({query}, {value})
	Sets a {value} to a first term found for {query}.
	It returns an instance itself (method chain).
	Note that it automatically add missing positional terms when not
	enough positional terms exist for the {query}.
>
	let args = Argument.new([
	      \ '--foo', 'foo',
	      \ '--bar', 'bar',
	      \ '--',
	      \ '--wow', 'wow',
	      \])
	let args = Argument.new(['--foo', '-f', '--bar=bar', '-bbar'])
	call args.set('-f|--foo', 'FOO')
	echo args.raw
	" -> ['--foo=FOO', '-fFOO', '--bar=bar', '-bbar']
<
				*Vital.Argument-args.apply()*
args.apply({query}, {fn})
	It applies {fn} to a first term found for {query}.
	The {fn} is called with [key, value] and should returns [key, value].
	When term is
	1. "--foo"	["--foo", 1] will be passed
	2. "--foo=foo"	["--foo", "foo"] will be passed
	3. "foo"	["", "foo"] will be passed
	It returns an instance itself (method chain).
>
	let args = Argument.new(['--foo=FOO', '-f', '--bar=bar', '-b'])
	call args.apply('-f|--foo', { k, v -> [k, tolower(v)] })
	echo args.raw
	" -> ['--foo=foo', '-f1', '--bar=bar', '-b1']
<
				*Vital.Argument-args.map()*
args.map({fn})
	TODO
				*Vital.Argument-args.filter()*
args.filter({fn})
	TODO

				*Vital.Argument-args.split()*
args.split()
	TODO

				*Vital.Argument-args.effective()*
args.effective([{replace}])
	TODO

				*Vital.Argument-args.residual()*
args.residual([{replace}])
	TODO


=============================================================================
vim:tw=78:fo=tcq2mM:ts=8:ft=help:norl
